---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Prepare for apples-to-apples comparisons

For every ACLI scenario and portfolio, create a corresponding random-normal scenario with the same mean and standard deviation over the ACLI-simulated number of years and simulations.

This will allow head-to-head comparison for each scenario-portfolio combination.

## Setup

```{r}
#| label: setup
#| output: false

source(here::here("report", "_common.R"))
source(fs::path(rptdir, "function_penmod.R")) # for flatmat

```


```{r}
#| label: get-acli-portfolios
#| output: false

acli <- readRDS(here::here("data", "acli_portfolios.rds"))
glimpse(acli)
count(acli, scenario)
count(acli, porttype)

```


## Prepare one or more random normal comparisons

Get portfolio statistics so that we can construct random normals corresponding to each scenario-portfolio combination.

```{r}
#| label: get-stats
#| output: false

# we need portfolio stats (mean, sd) so we can construct random normals corresponding to each
# scenario-portfolio combination
port_stats <- acli |> 
  filter(year > 0) |> 
  summarise(nsims=length(unique(sim)),
            nyears=length(unique(year)),
            meanlogreturn=mean(logreturn), 
            sdlogreturn=sd(logreturn),
            minlogreturn=min(logreturn),
            maxlogreturn=max(logreturn),
            .by=c(scenario, porttype))
port_stats

```


## Graph of means and standard deviations of scenarios and portfolios

Gang, we might want to do a graph like this (with fewer scenarios and better labeling). It's a nice summary of the range of results.

```{r}
#| label: scenario-portfolio-plot
#| output: true

port_stats |> 
  ggplot(aes(meanlogreturn, sdlogreturn, colour=porttype, label=scenario)) +
  geom_point() +
  geom_text_repel(vjust = -0.5, hjust = 0.5, max.overlaps = 15) +
  scale_color_manual(values=c("red", "blue")) +
  scale_x_continuous(name="mean", 
                     breaks = seq(0, 1, .0025),
                     labels = scales::percent_format(accuracy = .01)) +
  scale_y_continuous(name="standard deviation", 
                     breaks = seq(0, 1, .01),
                     labels = scales::percent_format(accuracy = .1)) +
  ggtitle(label = "Mean and standard deviation for ACLI scenarios",
          subtitle = "ACLI scenarios and portfolios") +
  guides(col= guide_legend(title= "Portfolio\ntype")) +
  theme_bw()


```


## Construct the corresponding random normal log returns


```{r}

# generate similar random normal ----

get_normal <- function(meanreturn, sdreturn, nsims, nyears, seed=123){
  set.seed(seed)
  irnorm <- rnorm(n = nsims * nyears, mean=meanreturn, sd=sdreturn)
  irnorm <- irnorm |> matrix(nrow = nsims, ncol = nyears)
  res <- list(ir_norm=irnorm, mean_norm=mean(irnorm), sd_norm=sd(irnorm))
  return(res)
}


rnorm_prep <- port_stats |> 
  rowwise() |> 
  mutate(rnormal=get_normal(meanlogreturn, sdlogreturn, nsims, nyears) |> list()) |> 
  mutate(mean_norm=pluck(rnormal, "mean_norm"),
         sd_norm=pluck(rnormal, "sd_norm"),
         irmat=pluck(rnormal, "ir_norm") |> list(),
         version="rnormal") |> 
  ungroup() |> 
  select(-rnormal, -minlogreturn, -maxlogreturn)
rnorm_prep

# prepare modeled data ----

make_irmat <- function(sim, year, return){
  # make an investment return matrix from a 
  nrows <- length(unique(sim))
  ncols <- length(unique(year))
  
  mat <- matrix(data = return, nrow=nrows, ncol = ncols, byrow = TRUE)
  mat
  list(mat)
}

port_prep <- acli |>
  filter(year != 0) |> 
  summarise(irmat=make_irmat(sim, year, logreturn), .by=c(scenario, porttype)) |> 
  right_join(rnorm_prep |> 
               select(scenario, porttype, nsims, nyears, meanlogreturn, sdlogreturn, mean_norm, sd_norm),
             by = join_by(scenario, porttype)) |> 
  mutate(version="model")

# stack modeled data and random normal data ---
stack <- bind_rows(rnorm_prep, port_prep) |> 
  relocate(version, .after = porttype) |> 
  arrange(scenario, porttype, version)

ht(stack)

saveRDS(stack, here::here("data", "acli_rnorm_portfolios.rds"))

```


## OLD -- Prepare one or more random normal comparisons


```{r}
#| label: prepare-acli-data
#| output: false

comp <- left_join(portfolio, rnportfolio,
                  by = join_by(sim, year)) |> 
  mutate(rnreturn=ifelse(year==0, 0, rnreturn),
         rnportfolio=ifelse(year==0, 1, rnportfolio))

ystats <- comp |> 
  filter(year > 0) |> 
  summarise(mean_acli=mean(portreturn), sd_acli=sd(portreturn),
            mean_rn=mean(rnreturn), sd_rn=sd(rnreturn), .by=year) |> 
  pivot_longer(-year) |> 
  separate(name, c("stat", "type"))


```

## Comparison of ACLI baseline to random normal with same mean and SD

### Observations

-   Grand mean and sd about the same
-   ACLI appears to have some modest autocorrelation in returns that random normal does not
-   ACLI portfolio appears to have slightly thinner tails than normal (can quantify this)
-   We need to decide on 2? portfolios to examine, and then run them through penmod.
-   However, these results suggest (to me) that we're unlikely to see large differences in risk measures vs. random normal. But will be good to examine more thoughtful portfolios and use actual risk measures.

### Grand mean and standard deviations - ACLI and random normal

```{r}

comp |> 
  filter(year > 0) |> 
  summarise(mean_acli=mean(portreturn), sd_acli=sd(portreturn),
            mean_rn=mean(rnreturn), sd_rn=sd(rnreturn))


```

### Mean and standard deviation by year

```{r}

ystats |> 
  filter(stat=="mean") |> 
  ggplot(aes(year, value, colour=type)) +
  geom_point() +
  geom_line() +
  geom_hline(yintercept = grand$mean) +
  ggtitle("Arithmetic mean return by year")

ystats |> 
  filter(stat=="sd") |> 
  ggplot(aes(year, value, colour=type)) +
  geom_point() +
  geom_line() +
  geom_hline(yintercept = grand$sd) +
  ggtitle("Standard deviation by year")

```

### Accumulation at year 30

```{r}


p <-  c(0, .05, .1, 0.25, 0.5, 0.75, .9, .95, 1)

y30 <- comp |> 
  filter(year==30) |>
  select(sim, year, portfolio, rnportfolio) |> 
  pivot_longer(c(portfolio, rnportfolio)) |> 
  group_by(name) |> 
  summarise(
    quantiles = list(quantile(value, probs = p))
    ) |> 
  unnest_wider(quantiles) |> 
  ungroup() |> 
  rename_with(~paste0("q", p * 100),
              .cols=-name)
y30

```
